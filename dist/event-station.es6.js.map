{"version":3,"file":null,"sources":["../src/addListener.ts","../src/matchListener.ts","../src/removeListener.ts","../src/removeListenerFromAll.ts","../src/applyListeners.ts","../src/getAllListeners.ts","../src/matchListeners.ts","../src/hasListener.ts","../src/injection.ts","../src/Listeners.ts","../src/makeStationId.ts","../src/options.ts","../src/EventStation.ts","../src/main.ts"],"sourcesContent":["import {Listener} from './Listener';\nimport {Meta} from './Meta';\n\n/** Adds the given listener to the given station meta */\nexport function addListener(stationMeta: Meta, listener: Listener): void {\n\n    const eventName = listener.eventName;\n    const listenersMap = stationMeta.listenersMap;\n\n    if (!listenersMap[eventName]) {\n        listenersMap[eventName] = [];\n    }\n\n    const stationMetas = listener.stationMetas;\n\n    if (!stationMetas) {\n        listener.stationMetas = [stationMeta];\n    } else {\n        stationMetas.push(stationMeta);\n    }\n\n    listenersMap[eventName].push(listener);\n    stationMeta.listenerCount++;\n\n    const hearer = listener.hearer;\n\n    if (hearer) {\n        hearer.stationMeta.hearingCount++;\n    }\n}\n","import {MatchingListener} from './MatchingListener';\n\n/**\n * Determines whether the given listeners match by performing an approximate match\n * using the `matchCallback`, `matchContext`, `hearer`, and `eventName` properties.\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n */\nexport function matchListener(matchingListener: MatchingListener, attachedListener: MatchingListener, exactMatch?: boolean): boolean {\n\n    if (exactMatch === true) {\n        return matchingListener == attachedListener;\n    }\n\n    const matchCallback = matchingListener.matchCallback;\n\n    if (\n        matchCallback\n        && matchCallback !== attachedListener.matchCallback\n    ) {\n        return false\n    }\n\n    const matchContext = matchingListener.matchContext;\n\n    if (\n        matchContext !== undefined\n        && matchContext !== attachedListener.matchContext\n    ) {\n        return false\n    }\n\n    const hearer = matchingListener.hearer;\n\n    if (\n        hearer\n        && hearer !== attachedListener.hearer\n    ) {\n        return false\n    }\n\n    const eventName = matchingListener.eventName;\n\n    if (\n        eventName !== undefined\n        && eventName !== attachedListener.eventName\n    ) {\n        return false\n    }\n\n    return true;\n}","import {Listener} from './Listener';\nimport {matchListener} from './matchListener';\nimport {Meta} from './Meta';\n\n/**\n * Removes all listeners that match the given listener from the given station meta.\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n */\nexport function removeListener(stationMeta: Meta, listener: Listener, exactMatch?: boolean): void {\n\n    if (stationMeta.listenerCount < 1) return;\n\n    const listenersMap = stationMeta.listenersMap;\n    const eventName = listener.eventName;\n    const attachedListeners = listenersMap[eventName];\n\n    if (!attachedListeners) return;\n\n    let attachedListenersCount = attachedListeners.length;\n\n    if (attachedListenersCount === 1) {\n\n        if (!matchListener(listener, attachedListeners[0], exactMatch)) return;\n\n        delete listenersMap[eventName];\n        stationMeta.listenerCount--;\n        reduceHearerHearingCount(listener);\n        removeMetaFromStation(stationMeta, listener);\n\n        return;\n    }\n\n    for (let i = 0, c = attachedListenersCount; i < c; i++) {\n\n        let attachedListener = attachedListeners[i];\n\n        if (!matchListener(listener, attachedListener, exactMatch)) continue;\n\n        /* Remove the listener from the given Meta */\n        attachedListeners.splice(i, 1);\n        stationMeta.listenerCount--;\n        i--;\n        c--;\n\n        reduceHearerHearingCount(listener);\n        removeMetaFromStation(stationMeta, listener);\n    }\n\n    if (attachedListeners.length < 1) {\n        delete listenersMap[eventName];\n    }\n}\n\nfunction removeMetaFromStation(targetMeta: Meta, listener: Listener) {\n\n    const stationMetas = listener.stationMetas;\n\n    if (!stationMetas) return;\n\n    if (stationMetas.length === 1) {\n        listener.stationMetas = undefined;\n        return;\n    }\n\n    const newStationMetas: Meta[] = [];\n\n    for (let stationMeta of stationMetas) {\n        if (stationMeta !== targetMeta) {\n            newStationMetas.push(stationMeta);\n        }\n    }\n\n    if (newStationMetas.length < 1) {\n        /*\n         * This line is necessary in the rare case that\n         * the exact same listener object has been added to\n         * a station multiple times, and is then removed from\n         * said station.\n         */\n        listener.stationMetas = undefined;\n    } else {\n        listener.stationMetas = newStationMetas;\n    }\n}\n\nfunction reduceHearerHearingCount(listener: Listener): void {\n\n    /*\n     * Update the hearingCount of given listener's hearer\n     */\n    const hearer = listener.hearer;\n\n    if (hearer) {\n        hearer.stationMeta.hearingCount--;\n    }\n}\n","import {Listener} from './Listener';\nimport {removeListener} from './removeListener';\n\n/** Removes the given listener from all of the station meta it's attached to */\nexport function removeListenerFromAll(listener: Listener): void {\n\n    const stationMetas = listener.stationMetas;\n\n    if (!stationMetas) return;\n\n    for (let stationMeta of stationMetas) {\n        removeListener(stationMeta, listener, true);\n    }\n}\n","import {EventStation} from './EventStation';\nimport {Listener} from './Listener';\nimport {removeListenerFromAll} from './removeListenerFromAll';\n\n/** Applies the given listeners with the given arguments */\nexport function applyListeners<P extends Promise<any>>(listeners: Listener[], originStation: EventStation, enableAsync: boolean, args: ListenerArguments): P[] | void {\n\n    const argsLength = args.length;\n    const stationMeta = originStation.stationMeta;\n\n    stationMeta.isPropagationStopped = false;\n\n    var promises: P[] = [];\n    var result: any;\n\n    for (let listener of listeners) {\n\n        if (stationMeta.isPropagationStopped) {\n            stationMeta.isPropagationStopped = false;\n            return;\n        }\n\n        if (listener.isPaused) continue;\n\n        const callback = listener.callback;\n        const context = listener.context;\n\n        if (callback) {\n            switch (argsLength) {\n                case 0:\n                    result = callback.call(context);\n                    break;\n                case 1:\n                    result = callback.call(context, args[0]);\n                    break;\n                case 2:\n                    result = callback.call(context, args[0], args[1]);\n                    break;\n                case 3:\n                    result = callback.call(context, args[0], args[1], args[2]);\n                    break;\n                default:\n                    result = callback.apply(context, args);\n                    break;\n            }\n        }\n\n        /*\n         * Is async enabled, and is the result a Promise-like object\n         */\n        if (\n            enableAsync\n            && result\n            && typeof result.then === 'function'\n            && typeof result.catch === 'function'\n        ) {\n            promises.push(<P>result);\n        }\n\n        const resolves = listener.resolves;\n\n        if (resolves) {\n\n            for (let resolve of resolves) {\n                resolve(listener);\n            }\n\n            listener.resolves = undefined;\n        }\n\n        const maxOccurrences = listener.maxOccurrences;\n        let occurrences = listener.occurrences;\n\n        if (maxOccurrences !== undefined) {\n\n            if (occurrences === undefined) {\n                occurrences = listener.occurrences = 1;\n            } else {\n                occurrences = ++listener.occurrences;\n            }\n\n            if (occurrences === maxOccurrences) {\n                removeListenerFromAll(listener);\n            }\n        }\n    }\n\n    return promises;\n}\n\nexport interface ListenerArguments {\n    [index: number]: any;\n    length: number;\n}\n","import {Listener} from './Listener';\nimport {Meta} from './Meta';\n\n/** Retrieves all listeners attached to the given Meta */\nexport function getAllListeners(stationMeta: Meta): Listener[] {\n\n    if (stationMeta.listenerCount < 1) return [];\n\n    const listenersMap = stationMeta.listenersMap;\n    var listeners: Listener[] = [];\n\n    for (let eventName in listenersMap) {\n        listeners = listeners.concat(listenersMap[eventName]);\n    }\n\n    return listeners;\n}\n","import {MatchingListener} from './MatchingListener';\nimport {matchListener} from './matchListener';\n\nexport function matchListeners(matchingListener: MatchingListener, attachedListeners: MatchingListener[], exactMatch?: boolean): boolean {\n\n    const count = attachedListeners.length;\n\n    if (count < 1) return false;\n\n    for (let attachedListener of attachedListeners) {\n\n        if (matchListener(matchingListener, attachedListener, exactMatch)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","import {getAllListeners} from './getAllListeners';\nimport {Listener} from './Listener';\nimport {MatchingListener} from './MatchingListener';\nimport {matchListeners} from './matchListeners';\nimport {Meta} from './Meta';\n\n/**\n * Determines whether the given listener is attached to the given station meta.\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n */\nexport function hasListener(stationMeta: Meta, listener: MatchingListener, exactMatch?: boolean): boolean {\n\n    const listenersMap = stationMeta.listenersMap;\n    const eventName = listener.eventName;\n    var attachedListeners: Listener[];\n\n    if (eventName === undefined) {\n\n        attachedListeners = getAllListeners(stationMeta);\n\n    } else {\n\n        attachedListeners = listenersMap[eventName];\n\n        if (!attachedListeners) {\n            return false;\n        }\n    }\n\n    return matchListeners(listener, attachedListeners, exactMatch);\n}\n","declare const global: any;\ndeclare const window: any;\n\nconst glob = typeof window !== 'undefined' ? window : global;\nconst $DefaultPromise: typeof Promise = glob.Promise;\n\nexport namespace deps {\n    /**\n     * A reference to the injected Rx namespace.\n     * @see inject()\n     */\n    export let $RxObservable: Rx.ObservableStatic | void = undefined;\n\n    /**\n     * A reference to the Promise object, or an injected Promise-like object.\n     * @see inject()\n     */\n    export let $Promise: typeof Promise | void = $DefaultPromise;\n};\n\n/**\n * Injects or overrides an optional dependency.\n *\n * Use this method to provide EventStation with the `rx` namespace.\n * Doing so enables the use of `Listeners.prototype.toObservable()`.\n *\n *     inject('rx', rx)\n *\n * EventStation will use the native Promise object by default.\n * If a Promise object isn't globally available, one can be\n * injected to be used in its place.\n *\n *     inject('Promise', YourPromiseObject)\n *\n * For example, Bluebird can be injected to override the Promise used\n * within EventStation instances.\n */\nexport function inject(name: 'rx', rx: any): void;\nexport function inject(name: 'Promise', Promise: any): void;\nexport function inject(name: string, obj: any): void;\nexport function inject(name: string, obj: any): void {\n\n    switch (name) {\n\n        case 'rx':\n            deps.$RxObservable = obj ? obj.Observable : obj;\n            break;\n\n        case 'Promise':\n            deps.$Promise = obj;\n            break;\n\n        default:\n            throw new Error('Invalid name');\n    }\n}\n\n/** Reset injected dependencies */\nexport function reset(): void {\n    deps.$RxObservable = undefined;\n    deps.$Promise = $DefaultPromise;\n}\n","import {addListener} from './addListener';\nimport {deps} from './injection';\nimport {Emitter} from './Emitter';\nimport {EventStation} from './EventStation';\nimport {hasListener} from './hasListener';\nimport {Listener} from './Listener';\nimport {MatchingListener} from './MatchingListener';\nimport {matchListeners} from './matchListeners';\nimport {Meta} from './Meta';\nimport {removeListener} from './removeListener';\nimport {removeListenerFromAll} from './removeListenerFromAll';\n\n/**\n * A class for operations targeting a collection of listeners\n */\nexport class Listeners {\n\n    /** @returns The number of listeners in the collection */\n    public get count(): number {\n        return this.listeners.length;\n    }\n\n    /** The station which the listeners originate from */\n    private originStation: Emitter;\n\n    /** An array of listeners */\n    private listeners: Listener[];\n\n    constructor(originStation: Emitter, listeners: Listener[]) {\n        this.originStation = originStation;\n        this.listeners = listeners;\n    }\n\n    /**\n     * Sets each listener's maximum occurrence\n     */\n    public occur(maxOccurrences: number): Listeners {\n\n        if (maxOccurrences < 1) {\n            throw new Error(\"The maximum occurrences must be greater than or equal to one.\");\n        }\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.maxOccurrences = maxOccurrences;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets each listener's callback function\n     */\n    public calling(callback: Function): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.callback = callback;\n            listener.matchCallback = callback;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets each listener's callback function, and maximum occurrence to one(1)\n     */\n    public once(callback: Function): Listeners {\n\n        return this.calling(callback).occur(1);\n    }\n\n    /**\n     * Removes the listeners from all stations\n     */\n    public off(): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            removeListenerFromAll(listener);\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the context of each listener\n     */\n    public using(context: any): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.context = context;\n            listener.matchContext = context;\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds each listener to the given station\n     */\n    public addTo(station: EventStation): Listeners {\n\n        const listeners = this.listeners;\n        const stationMeta = station.stationMeta;\n\n        for (let listener of listeners) {\n\n            const crossOrigin = listener.crossOrigin;\n\n            if (crossOrigin && crossOrigin !== station) {\n                throw new Error(\"Cross-emitter listeners can only be attached to their origin station.\");\n            }\n\n            addListener(stationMeta, listener);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes each listener from the given station\n     */\n    public removeFrom(station: EventStation): Listeners {\n\n        const listeners = this.listeners;\n        const stationMeta = station.stationMeta;\n\n        for (let listener of listeners) {\n            removeListener(stationMeta, listener, true);\n        }\n\n        return this;\n    }\n\n    /**\n     * Moves the listeners to another station.\n     * This method changes the origin station.\n     */\n    public moveTo(station: Emitter): Listeners {\n\n        this.removeFrom(this.originStation);\n        this.originStation = station;\n        this.addTo(station);\n\n        return this;\n    }\n\n    /**\n     * Determines whether any listener in the collection matches the given listener.\n     * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n     */\n    public has(matchingListener: MatchingListener, exactMatch?: boolean): boolean {\n        return matchListeners(matchingListener, this.listeners, exactMatch);\n    }\n\n    /**\n     * Adds the listeners to the origin station\n     */\n    public attach(): Listeners {\n        return this.addTo(this.originStation);\n    }\n\n    /**\n     * Removes the listeners from the origin station\n     */\n    public detach(): Listeners {\n        return this.removeFrom(this.originStation);\n    }\n\n    /**\n     * Determines whether any of the listeners are attached to the given station.\n     * If no station is given, the method determines whether any of the listeners\n     * are attached to *any* station.\n     */\n    public isAttachedTo(station?: EventStation): boolean {\n\n        if (!station) {\n            return isListenersAttached(this.listeners);\n        }\n\n        return hasListeners(station.stationMeta, this.listeners, true);\n    }\n\n    /**\n     * Determines whether any of the listeners are attached to the origin station\n     */\n    public isAttached(): boolean {\n        return this.isAttachedTo(this.originStation);\n    }\n\n    /**\n     * Pauses each listener\n     */\n    public pause(): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.isPaused = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Un-pauses each listener\n     */\n    public resume(): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.isPaused = false;\n        }\n\n        return this;\n    }\n\n    /**\n     * Determines whether any of listeners are paused\n     */\n    public isPaused(): boolean {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            if (listener.isPaused) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @returns An iterable object (array) containing a promise\n     * for each listener that resolves when said listener is applied.\n     * This method is dependant on `Promise`.\n     * @see inject()\n     */\n    public toPromises(): Array<Promise<Listener>> {\n\n        const promises: Array<Promise<Listener>> = [];\n        const listeners = this.listeners;\n\n        for (let i = 0, c = listeners.length; i < c; i++) {\n            let listener = listeners[i];\n\n            promises[i] = makePromise(listener);\n        }\n\n        return promises;\n    }\n\n    /**\n     * @returns A promise that resolves when all of the listeners\n     * have been applied at least once.\n     * This method is dependant on `Promise`.\n     * @see inject()\n     */\n    public all(): Promise<Listener[]> {\n\n        return deps.$Promise.all<Listener>(this.toPromises());\n    }\n\n    /**\n     * @returns A promise that resolves when one of the listeners is applied.\n     * This method is dependant on `Promise`.\n     * @see inject()\n     */\n    public race(): Promise<Listener> {\n\n        return deps.$Promise.race<Listener>(this.toPromises());\n    }\n\n    /**\n     * Un-pauses each listener, and resets each listener's occurrence count\n     */\n    public reset(): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let listener of listeners) {\n            listener.occurrences = undefined;\n            listener.isPaused = undefined;\n        }\n\n        return this;\n    }\n\n    /** Similar to Array.prototype.forEach() */\n    public forEach(func: ForEachCallback): Listeners {\n\n        const listeners = this.listeners;\n\n        for (let i = 0, c = listeners.length; i < c; i++) {\n            let listener = listeners[i];\n\n            func(listener, i, listeners);\n        }\n\n        return this;\n    }\n\n    /** Retrieves a listener located at the given index */\n    public get(index: number): Listener {\n        return this.listeners[index];\n    }\n\n    /** Retrieves the index of the given listener */\n    public index(listener: Listener): number | void {\n\n        const listeners = this.listeners;\n\n        for (let i = 0, c = listeners.length; i < c; i++) {\n            if (listener === listeners[i]) return i;\n        }\n    }\n\n    /**\n     * @returns A new `Listeners` object containing a clone of each Listener\n     */\n    public clone(): Listeners {\n        const clonedListeners = this.listeners.map(cloneListener);\n\n        return new Listeners(this.originStation, clonedListeners);\n    }\n}\n\n/** Creates a `Promise` and adds its `resolve` function to the listener's `resolves` array */\nfunction makePromise(listener: Listener): Promise<Listener> {\n\n    if (!deps.$Promise) {\n        throw new Error('No promises implementation available.');\n    }\n\n    return new deps.$Promise<Listener>(function (resolve) {\n\n        if (!listener.resolves) {\n            listener.resolves = [resolve];\n        } else {\n            listener.resolves.push(resolve);\n        }\n    });\n}\n\n/**\n * Clones the given listener\n * Does not clone the listener's `stationMetas` or `resolves` properties\n * @throws an `Error` if the listener is a cross-emitter listener\n */\nfunction cloneListener(listener: Listener): Listener {\n\n    if (listener.hearer) {\n        throw new Error(\"Cross-emitter listeners can not be cloned.\");\n    }\n\n    return {\n        eventName: listener.eventName,\n        callback: listener.callback,\n        context: listener.context,\n        matchCallback: listener.matchCallback,\n        matchContext: listener.matchContext,\n        isPaused: listener.isPaused,\n        occurrences: listener.occurrences,\n        maxOccurrences: listener.maxOccurrences,\n    };\n}\n\n/** Determines whether the given listeners are attached to any stations */\nexport function isListenersAttached(listeners: Listener[]) {\n    for (let listener of listeners) {\n        if (isListenerAttached(listener)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Determines whether the given listener is attached to any stations */\nexport function isListenerAttached(listener: Listener): boolean {\n    return listener.stationMetas !== undefined;\n}\n\n/**\n * Determines whether the given station meta has listeners that match the given listeners\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n */\nfunction hasListeners(stationMeta: Meta, listeners: Listener[], exactMatch?: boolean) {\n    for (let listener of listeners) {\n        if (hasListener(stationMeta, listener, exactMatch)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport interface ForEachCallback {\n    (listener: Listener, index: number, listeners: Listener[]): any;\n}\n","/** Iterator for generating unique station IDs */\nvar stationIdIterator: number = 0;\n\n/** Generates a unique ID for EventStation instances */\nexport function makeStationId(): string {\n    return String(++stationIdIterator);\n}\n","/** Container for global configuration options */\nexport const defaultOptions = {\n    delimiter: ' ',\n    emitAllEvent: true,\n    enableDelimiter: true,\n    enableRegExp: false,\n    regExpMarker: '%',\n};\n\n/** Container for global configuration options */\nexport const globalOptions = mergeOptions({}, defaultOptions);\n\n/** Resets the global configuration to defaults */\nexport function reset(): void {\n    mergeOptions(globalOptions, defaultOptions)\n}\n\n/** Modifies the default global configuration */\nexport function config(opts: Options): void {\n    let testOptions = mergeOptions({}, globalOptions, opts);\n\n    assertOptions(testOptions);\n\n    mergeOptions(globalOptions, opts);\n}\n\n/**\n * Validates the given options\n * @throws Error\n */\nexport function assertOptions<T extends typeof defaultOptions>(opts: T) {\n    if (opts.delimiter === '') {\n        throw new Error(\"Invalid option: Delimiters can't be empty strings.\");\n    }\n\n    if (opts.regExpMarker === '') {\n        throw new Error(\"Invalid option: RegExp markers can't be empty strings.\");\n    }\n\n    if (opts.regExpMarker && opts.delimiter && opts.regExpMarker.indexOf(opts.delimiter) >= 0) {\n        throw new Error(\"Invalid option: RegExp markers can't contain the delimiter string.\");\n    }\n}\n\nexport function mergeOptions<T extends typeof defaultOptions>(target: any, ...sources: any[]): T {\n\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (let option in defaultOptions) {\n            let isValidOption = defaultOptions.hasOwnProperty(option);\n            let value = source[option];\n\n            if (isValidOption && value != null) {\n                target[option] = value;\n            }\n        }\n    }\n\n    return target;\n}\n\n/**\n* See the [configuration section](http://morrisallison.github.io/event-station/usage.html#configuration)\n* of the usage documentation for general usage.\n*/\nexport interface Options {\n    /**\n     * The character used to delimit event names in a string.\n     * `\" \"` (space) by default.\n     */\n    delimiter?: string;\n    /**\n     * Determines whether a station emits an `\"all\"` event for every event that is emitted.\n     * `true` by default.\n     */\n    emitAllEvent?: boolean;\n    /**\n     * Determines whether a station can use delimited event names.\n     * `true` by default.\n     */\n    enableDelimiter?: boolean;\n    /**\n     * Determines whether a station can use regular expression listeners.\n     * `false` by default.\n     */\n    enableRegExp?: boolean;\n    /**\n     * A string used to mark regular expression listeners.\n     * `\"%\"` by default.\n     */\n    regExpMarker?: string;\n    [key: string]: string | boolean | void;\n    [key: number]: void;\n}","import {addListener} from './addListener';\nimport {applyListeners} from './applyListeners';\nimport {Emitter} from './Emitter';\nimport {getAllListeners} from './getAllListeners';\nimport {hasListener} from './hasListener';\nimport {Listener} from './Listener';\nimport {Listeners} from './Listeners';\nimport {ListenersMap} from './ListenersMap';\nimport {makeStationId} from './makeStationId';\nimport {matchListener} from './matchListener';\nimport {Meta} from './Meta';\nimport {removeListener} from './removeListener';\nimport {StationMap} from './StationMap';\nimport * as injection from './injection';\nimport * as options from './options';\n\n/**\n * Event emitter class and namespace\n */\nexport class EventStation {\n\n    /** Container for the station's context */\n    public stationMeta: Meta;\n\n    constructor(options?: options.Options) {\n        EventStation.init(this, options);\n    }\n\n    /** An ID unique to all stations */\n    public get stationId(): string {\n        return this.stationMeta.stationId;\n    }\n\n    /** Number of listeners attached to the station */\n    public get listenerCount(): number {\n        return this.stationMeta.listenerCount;\n    }\n\n    /**\n     * Number of listeners attached to other stations by the station.\n     * This value is increased by using `hear()` and `hearOnce()`.\n     */\n    public get hearingCount(): number {\n        return this.stationMeta.hearingCount;\n    }\n\n    /** Array of event names which have listeners on the station */\n    public get listenerEventNames(): string[] {\n        return Object.getOwnPropertyNames(this.stationMeta.listenersMap);\n    }\n\n    /**\n     * Creates and attaches listeners to the station\n     */\n    public on(listenerMap: CallbackMap, context?: any): Listeners;\n    public on(eventNames: string[], callback?: Function, context?: any): Listeners;\n    public on(eventName: string, callback?: Function, context?: any): Listeners;\n    public on(q: any, r?: any, s?: any): Listeners {\n\n        const stationMeta = this.stationMeta;\n        const listeners = makeListeners(this, false, q, r, s);\n\n        for (let listener of listeners) {\n            addListener(stationMeta, listener);\n        }\n\n        return new Listeners(this, listeners);\n    }\n\n    /**\n     * Creates and attaches listeners to the station that are applied once and removed\n     */\n    public once(listenerMap: CallbackMap, context?: any): Listeners;\n    public once(eventNames: string[], callback?: Function, context?: any): Listeners;\n    public once(eventName: string, callback?: Function, context?: any): Listeners;\n    public once(q: any, r?: any, s?: any): Listeners {\n\n        return this.on(q, r, s).occur(1);\n    }\n\n    /**\n     * Removes listeners from the station that match the given arguments.\n     * If no arguments are given, all listeners will be removed;\n     * including listeners that were attached via `hear()` or `hearOnce()`.\n     */\n    public off(): void;\n    public off(listenerMap: CallbackMap, context?: any): void;\n    public off(eventNames: string[], callback?: Function, context?: any): void;\n    public off(eventName: string, callback?: Function, context?: any): void;\n    public off(q?: any, r?: any, s?: any): void {\n\n        const stationMeta = this.stationMeta;\n\n        if (stationMeta.listenerCount < 1) return;\n\n        // If no listener targets were given\n        if (q === undefined) {\n            removeAllListeners(stationMeta);\n            return;\n        }\n\n        if (\n            r === undefined\n            && s === undefined\n            && typeof q === 'string'\n            && (!stationMeta.enableDelimiter || q.indexOf(stationMeta.delimiter) < 0)\n        ) {\n            removeListeners(q, stationMeta);\n            return;\n        }\n\n        const listeners = makeListeners(this, true, q, r, s);\n\n        for (let listener of listeners) {\n            removeListener(stationMeta, listener);\n        }\n    }\n\n    /**\n     * Creates and attaches listeners to another station.\n     * Listeners attached using this method can be removed specifically by using `disregard()`.\n     */\n    public hear(station: Emitter, listenerMap: CallbackMap, context?: any): Listeners;\n    public hear(station: Emitter, eventNames: string[], callback?: Function, context?: any): Listeners;\n    public hear(station: Emitter, eventName: string, callback?: Function, context?: any): Listeners;\n    public hear(station: Emitter, q: any, r?: any, s?: any): Listeners {\n\n        const heardStations = this.stationMeta.heardStations;\n        const listeners = makeListeners(this, false, q, r, s);\n        const targetStationMeta = station.stationMeta;\n\n        for (let listener of listeners) {\n            listener.hearer = this;\n            listener.crossOrigin = station;\n            addListener(targetStationMeta, listener);\n            heardStations[station.stationId] = station;\n        }\n\n        return new Listeners(station, listeners);\n    }\n\n    /**\n     * Attaches listeners to another station that are applied once and removed\n     * Listeners attached using this method can be removed specifically by using `disregard()`.\n     */\n    public hearOnce(station: Emitter, listenerMap: CallbackMap, context?: any): Listeners;\n    public hearOnce(station: Emitter, eventNames: string[], callback?: Function, context?: any): Listeners;\n    public hearOnce(station: Emitter, eventName: string, callback?: Function, context?: any): Listeners;\n    public hearOnce(station: Emitter, q: any, r?: any, s?: any): Listeners {\n\n        return this.hear(station, q, r, s).occur(1);\n    }\n\n    /**\n     * Removes listeners from other stations that were attached by the station\n     * via `hear()` and `hearOnce()`. If no arguments are given, all listeners\n     * that were attached to other stations are removed.\n     */\n    public disregard(): void;\n    public disregard(target: EventStation | EventStation[]): void;\n    public disregard(target: EventStation | EventStation[], listenerMap: CallbackMap, context?: any): void;\n    public disregard(target: EventStation | EventStation[], eventNames: string[], callback?: Function, context?: any): void;\n    public disregard(target: EventStation | EventStation[], eventName: string, callback?: Function, context?: any): void;\n    public disregard(target?: any, q?: any, r?: any, s?: any): void {\n\n        const stationMeta = this.stationMeta;\n\n        if (stationMeta.hearingCount < 1) return;\n\n        var isRemovingAll = false;\n        var listeners: Listener[] = [];\n\n        // If no listener targets were given\n        if (q === undefined) {\n            isRemovingAll = true;\n        } else {\n            listeners = makeListeners(this, true, q, r, s);\n        }\n\n        const stations = getTargetedStations(stationMeta, target);\n\n        for (let x = 0, y = stations.length; x < y; x++) {\n\n            let station = stations[x];\n            let targetStationMeta = station.stationMeta;\n\n            if (isRemovingAll) {\n                q = station.listenerEventNames;\n                listeners = makeListeners(this, true, q, r, s);\n            }\n\n            for (let listener of listeners) {\n                listener.hearer = this;\n                removeListener(targetStationMeta, listener);\n            }\n        }\n\n        if (isRemovingAll) {\n            stationMeta.heardStations = Object.create(null);\n        } else {\n            cleanHeardStations(this);\n        }\n    }\n\n    /**\n     * Determines whether the station has attached listeners that match the\n     * given arguments. If no arguments are given, the method determines\n     * whether the station has any attached listeners.\n     */\n    public isHeard(): boolean;\n    public isHeard(listenerMap: CallbackMap, context?: any): boolean;\n    public isHeard(eventNames: string[], callback?: Function, context?: any): boolean;\n    public isHeard(eventName: string, callback?: Function, context?: any): boolean;\n    public isHeard(q?: any, r?: any, s?: any): boolean {\n\n        const stationMeta = this.stationMeta;\n        const listenerCount = stationMeta.listenerCount;\n\n        if (listenerCount < 1) return false;\n\n        if (arguments.length < 1) {\n            // Determine if any listeners are attached\n            return listenerCount > 0;\n        }\n\n        const listeners = makeListeners(this, true, q, r, s);\n\n        for (let listener of listeners) {\n            if (hasListener(stationMeta, listener)) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determines whether other stations have listeners matching the given\n     * arguments that were attached by the station via `hear()` and `hearOnce()`.\n     * If no arguments are given, the method determines whether other stations\n     * have any listeners attached by the station via `hear()` and `hearOnce()`.\n     */\n    public isHearing(): boolean;\n    public isHearing(target: EventStation | EventStation[]): boolean;\n    public isHearing(target: EventStation | EventStation[], listenerMap: CallbackMap): boolean;\n    public isHearing(target: EventStation | EventStation[], eventNames: string[], callback?: Function): boolean;\n    public isHearing(target: EventStation | EventStation[], eventName: string, callback?: Function): boolean;\n    public isHearing(target?: any, q?: any, r?: any, s?: any): boolean {\n\n        const stationMeta = this.stationMeta;\n\n        if (stationMeta.hearingCount < 1) return false;\n\n        const stations = getTargetedStations(stationMeta, target);\n        var matchAllListeners: boolean = false;\n\n        var listeners: Listener[] = [];\n\n        // If no listener targets were given\n        if (q) {\n            listeners = makeListeners(this, true, q, r, s);\n        } else {\n            matchAllListeners = true;\n        }\n\n        for (let x = 0, y = stations.length; x < y; x++) {\n\n            let station = stations[x];\n            let targetStationMeta = station.stationMeta;\n\n            if (matchAllListeners) {\n                q = station.listenerEventNames;\n                listeners = makeListeners(this, true, q, r, s);\n            }\n\n            for (let listener of listeners) {\n                listener.hearer = this;\n\n                if (hasListener(targetStationMeta, listener)) return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Emits events on the station.\n     * Parameters after the first are passed to each listener's callback function.\n     */\n    public emit(eventNames: string[], ...args: any[]): void;\n    public emit(eventName: string, ...args: any[]): void;\n    public emit(input: any, ...args: any[]): void {\n\n        const stationMeta = this.stationMeta;\n\n        if (stationMeta.listenerCount < 1) return;\n\n        const eventNames = parseEventNames(input, stationMeta);\n\n        for (let eventName of eventNames) {\n            emitEvent(eventName, this, false, args);\n        }\n    }\n\n    /**\n     * Emits events on the station, and then completes asynchronously.\n     * Parameters after the first are passed to each listener's callback function.\n     * @returns A `Promise` that resolves after all of the return listener promises resolve.\n     */\n    public emitAsync<R extends any>(eventNames: string[], ...args: any[]): Promise<R[]>;\n    public emitAsync<R extends any>(eventName: string, ...args: any[]): Promise<R[]>;\n    public emitAsync<R extends any>(input: any, ...args: any[]): Promise<R[]> {\n\n        if (!injection.deps.$Promise) {\n            throw new Error('No promises implementation available.');\n        }\n\n        const stationMeta = this.stationMeta;\n\n        if (stationMeta.listenerCount < 1) {\n            return injection.deps.$Promise.resolve([]);\n        }\n\n        const eventNames = parseEventNames(input, stationMeta);\n\n        var promises: Promise<R>[] = [];\n\n        for (let eventName of eventNames) {\n            promises = promises.concat(\n                emitEvent<Promise<R>>(eventName, this, true, args)\n            );\n        }\n\n        if (promises.length > 0) {\n            return injection.deps.$Promise.all<R>(promises);\n        } else {\n            return injection.deps.$Promise.resolve([]);\n        }\n    }\n\n    /**\n     * Creates listeners without attaching them to the station\n     */\n    public makeListeners(listenerMap: CallbackMap, context?: any): Listeners;\n    public makeListeners(eventNames: string[], callback?: Function, context?: any): Listeners;\n    public makeListeners(eventName: string, callback?: Function, context?: any): Listeners;\n    public makeListeners(q: any, r?: any, s?: any): Listeners {\n\n        const listeners = makeListeners(this, false, q, r, s);\n\n        return new Listeners(this, listeners);\n    }\n\n    /**\n     * @returns Listeners from the station that match the given arguments.\n     * If no arguments are given, all listeners will be returned;\n     * including listeners that were attached via `hear()` or `hearOnce()`.\n     */\n    public getListeners(): Listeners;\n    public getListeners(listenerMap: CallbackMap, context?: any): Listeners;\n    public getListeners(eventNames: string[], callback?: Function, context?: any): Listeners;\n    public getListeners(eventName: string, callback?: Function, context?: any): Listeners;\n    public getListeners(q?: any, r?: any, s?: any): Listeners | void {\n\n        const attachedListeners = getAllListeners(this.stationMeta);\n\n        if (attachedListeners.length < 1) {\n            return undefined;\n        }\n        if (arguments.length < 1) {\n            return new Listeners(this, attachedListeners);\n        }\n\n        const matchingListeners = makeListeners(this, true, q, r, s);\n        const listeners: Listener[] = [];\n\n        for (let attachedListener of attachedListeners) {\n            for (let matchingListener of matchingListeners) {\n                if (matchListener(matchingListener, attachedListener)) {\n                    listeners.push(attachedListener);\n                    break;\n                }\n            }\n        }\n\n        // No matching listeners were found\n        if (listeners.length < 1) return undefined;\n\n        return new Listeners(this, listeners);\n    }\n\n    /**\n     * @returns A new Rx.Observable object from the station\n     * This method is dependant on `rx`.\n     * @see inject()\n     */\n    public toObservable<T>(eventNames: string[], context?: any, selector?: (args: any[]) => T): Rx.Observable<T>;\n    public toObservable<T>(eventName: string, context?: any, selector?: (args: any[]) => T): Rx.Observable<T>;\n    public toObservable<T>(q: any, s?: any, selector?: (args: any[]) => T): Rx.Observable<T> {\n\n        if (!injection.deps.$RxObservable) {\n            throw new Error('Rx has not been injected. See documentation for details.');\n        }\n\n        return injection.deps.$RxObservable.fromEventPattern<T>((r) => {\n            this.on(q, r, s);\n        }, (r) => {\n            this.off(q, r, s);\n        }, selector);\n    }\n\n    /**\n     * Stops the propagation of an emitted event. When called, this method effectively does\n     * nothing if an event is not being emitted at the time.\n     */\n    public stopPropagation(): void {\n        this.stationMeta.isPropagationStopped = true;\n    }\n\n    /**\n     * Adds the given listener to the station\n     */\n    public addListener(listener: Listener): void {\n        addListener(this.stationMeta, listener);\n    }\n\n    /**\n    * Removes all listeners that match the given listener from the station\n    * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n    */\n    public removeListener(listener: Listener, exactMatch?: boolean): void {\n        removeListener(this.stationMeta, listener, exactMatch);\n    }\n\n    /**\n    * Determines whether any listener attached to the station matches the given listener.\n    * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\n    */\n    public hasListener(listener: Listener, exactMatch?: boolean): boolean {\n        return hasListener(this.stationMeta, listener, exactMatch);\n    }\n\n    /** Initializes the given object */\n    public static init(obj: any, options?: options.Options): typeof EventStation {\n        obj.stationMeta = makeStationMeta(options);\n\n        return EventStation;\n    }\n\n    public static inject(name: string, obj: any): typeof EventStation {\n        injection.inject(name, obj);\n\n        return EventStation;\n    }\n\n    /** Modifies the global configuration */\n    public static config(opts: options.Options): typeof EventStation {\n        options.config(opts);\n\n        return EventStation;\n    }\n\n    /** Resets the global configuration and injected dependencies */\n    public static reset(): typeof EventStation {\n        options.reset();\n        injection.reset();\n\n        return EventStation;\n    }\n\n    /**\n     * Extends an object with EventStation's public members\n     */\n    public static extend<T extends Emitter>(obj: any): T {\n        const proto = EventStation.prototype;\n\n        for (let propertyName in proto) {\n\n            const descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n            const newDescriptor: PropertyDescriptor = { configurable: true };\n\n            if (descriptor.get !== undefined) {\n                newDescriptor.get = descriptor.get;\n            } else {\n                newDescriptor.value = descriptor.value;\n            }\n\n            Object.defineProperty(obj, propertyName, newDescriptor);\n        }\n\n        return obj;\n    }\n\n    public static make(): Emitter {\n        var station = EventStation.extend({});\n\n        EventStation.init(station);\n\n        return station;\n    }\n}\n\nfunction parseEventNames(eventNames: string[], options: Meta): string[];\nfunction parseEventNames(eventName: string, options: Meta): string[];\nfunction parseEventNames(input: any, options: Meta): string[] {\n    var names: string[];\n\n    if (typeof input === 'string') {\n\n        const delimiter = options.delimiter;\n\n        if (options.enableDelimiter && delimiter) {\n            names = input.split(delimiter);\n        } else {\n            names = [input];\n        }\n\n    } else if (Array.isArray(input)) {\n        names = input;\n    } else {\n        throw new Error(\"Invalid first argument\");\n    }\n\n    return names;\n}\n\n/** Creates a new station meta object from the given configuration options */\nfunction makeStationMeta(config: options.Options = {}): Meta {\n    const state = {\n        heardStations: Object.create(null),\n        hearingCount: 0,\n        isPropagationStopped: false,\n        listenerCount: 0,\n        listenersMap: Object.create(null),\n        stationId: makeStationId(),\n    };\n\n    const meta = options.mergeOptions<Meta>(state, options.globalOptions, config);\n\n    options.assertOptions(meta);\n\n    return meta;\n}\n\n/**\n * Makes an array of listeners from the given parameters\n * This function normalizes the four ways to make listeners.\n */\nfunction makeListeners(originStation: Emitter, isMatching: boolean, listenerMap: CallbackMap, context?: EventStation): Listener[];\nfunction makeListeners(originStation: Emitter, isMatching: boolean, eventNames: string[], callback?: Function, context?: EventStation): Listener[];\nfunction makeListeners(originStation: Emitter, isMatching: boolean, eventName: string, callback?: Function, context?: EventStation): Listener[];\nfunction makeListeners(originStation: Emitter, isMatching: boolean, q: any, r?: any, s?: any): Listener[] {\n\n    if (typeof q === 'string') {\n\n        const stationMeta = originStation.stationMeta;\n        const enableDelimiter = stationMeta.enableDelimiter;\n        const delimiter = stationMeta.delimiter;\n\n        if (enableDelimiter && q.indexOf(delimiter) >= 0) {\n            q = (<string>q).split(delimiter);\n            return makeListenersFromArray(originStation, isMatching, q, r, s);\n        }\n\n        return [{\n            eventName: q,\n            callback: r,\n            context: !isMatching && s === undefined ? originStation : s,\n            matchCallback: r,\n            matchContext: s,\n        }];\n    }\n\n    if (Array.isArray(q)) {\n        return makeListenersFromArray(originStation, isMatching, q, r, s);\n    }\n\n    if (typeof q === 'object') {\n        return makeListenersFromMap(originStation, isMatching, q, r);\n    }\n\n    throw new Error(\"Invalid arguments\");\n}\n\n\n/** Makes an array of listeners from the given listener map */\nfunction makeListenersFromMap(originStation: Emitter, isMatching: boolean, listenerMap: CallbackMap, context: any): Listener[] {\n\n    const listeners: Listener[] = [];\n\n    for (let eventName in listenerMap) {\n\n        listeners.push({\n            eventName: eventName,\n            callback: listenerMap[eventName],\n            context: !isMatching && context === undefined ? originStation : context,\n            matchCallback: listenerMap[eventName],\n            matchContext: context,\n        });\n    }\n\n    return listeners;\n}\n\n/** Makes an array of listeners from the given event name array */\nfunction makeListenersFromArray(originStation: Emitter, isMatching: boolean, eventNames: string[], callback: Function, context: any): Listener[] {\n\n    const listeners: Listener[] = [];\n\n    for (let i = 0, l = eventNames.length; i < l; i++) {\n\n        listeners.push({\n            eventName: eventNames[i],\n            callback: callback,\n            context: !isMatching && context === undefined ? originStation : context,\n            matchContext: context,\n            matchCallback: callback,\n        });\n    }\n\n    return listeners;\n}\n\nfunction emitEvent<P extends Promise<any>>(eventName: string, originStation: Emitter, enableAsync: boolean, args: any[]): P[] {\n\n    const stationMeta = originStation.stationMeta;\n    const listenersMap = stationMeta.listenersMap;\n\n    var listeners: Listener[];\n\n    if (stationMeta.enableRegExp) {\n        listeners = searchListeners(eventName, listenersMap, stationMeta.regExpMarker);\n    } else {\n        listeners = listenersMap[eventName];\n    }\n\n    var promises: P[] = [];\n\n    if (listeners) {\n\n        let result = applyListeners<P>(listeners, originStation, enableAsync, args);\n\n        if (enableAsync && result) {\n            promises = promises.concat(result);\n        }\n    }\n\n    const listenersMapAll = listenersMap['all'];\n\n    if (stationMeta.emitAllEvent && listenersMapAll) {\n\n        let argsAll = args.slice();\n\n        argsAll.splice(0, 0, eventName);\n\n        let result = applyListeners<P>(listenersMapAll, originStation, enableAsync, argsAll);\n\n        if (enableAsync && result) {\n            promises = promises.concat(result);\n        }\n    }\n\n    return promises;\n}\n\n/**\n * Retrieves listeners from the given listener map\n * that match the given event name. Specifically,\n * this function recognizes regular expression listeners.\n */\nfunction searchListeners(eventName: string, listenersMap: ListenersMap, regExpMarker: string): Listener[] {\n\n    var listeners: Listener[] = [];\n\n    for (let expression in listenersMap) {\n\n        if (expression.indexOf(regExpMarker) === 0) {\n\n            if (new RegExp(expression.substr(regExpMarker.length)).test(eventName)) {\n                listeners = listeners.concat(listenersMap[expression]);\n            }\n\n        } else if (expression === eventName) {\n\n            listeners = listeners.concat(listenersMap[eventName]);\n        }\n    }\n\n    return listeners;\n}\n\n/** Clean the `heardStations` property of the meta of the given station */\nfunction cleanHeardStations(station: EventStation): void {\n\n    const stationMap: StationMap = Object.create(null);\n    const heardStations = station.stationMeta.heardStations;\n\n    for (let stationId in heardStations) {\n\n        const heardStation = heardStations[stationId];\n\n        if (hasListener(heardStation.stationMeta, { hearer: station })) {\n            stationMap[stationId] = heardStation;\n        }\n    }\n\n    station.stationMeta.heardStations = stationMap;\n}\n\n/** Removes all listeners from then given station meta */\nfunction removeAllListeners(stationMeta: Meta): void {\n\n    const listenersMap = stationMeta.listenersMap;\n\n    for (let eventName in listenersMap) {\n\n        const listeners = listenersMap[eventName];\n\n        for (let listener of listeners) {\n            const hearer = listener.hearer;\n\n            if (hearer) {\n                hearer.stationMeta.hearingCount--;\n            }\n        }\n    }\n\n    stationMeta.listenerCount = 0;\n    stationMeta.listenersMap = Object.create(null);\n}\n\n/** Removes all listeners for a particular event from the given station meta */\nfunction removeListeners(eventName: string, stationMeta: Meta): void {\n\n    const listenersMap = stationMeta.listenersMap;\n    const listeners = listenersMap[eventName];\n\n    if (listeners === undefined) return;\n\n    const count = listeners.length;\n\n    for (let i = 0; i < count; i++) {\n\n        const listener = listeners[i];\n        const hearer = listener.hearer;\n\n        if (hearer) {\n            hearer.stationMeta.hearingCount--;\n        }\n    }\n\n    stationMeta.listenerCount = stationMeta.listenerCount - count;\n    delete listenersMap[eventName];\n}\n\n/**\n * Retrieves the targeted stations from the given parameters\n * This function normalizes the the target station for\n * cross-emitter listening methods.\n */\nfunction getTargetedStations(stationMeta: Meta, target?: EventStation | EventStation[]): EventStation[] {\n\n    if (target === undefined) {\n        return getHeardStations(stationMeta);\n    }\n\n    if (Array.isArray(target)) {\n        return <EventStation[]>target;\n    }\n\n    if ((<EventStation>target).stationMeta) {\n        return [<EventStation>target];\n    }\n\n    throw new Error(\"Invalid target\");\n}\n\n/**\n * @returns the heard stations of a given station's meta as an array\n */\nfunction getHeardStations(stationMeta: Meta): EventStation[] {\n\n    const stations: EventStation[] = [];\n    const heardStations = stationMeta.heardStations;\n\n    for (let stationId in heardStations) {\n        stations.push(heardStations[stationId]);\n    }\n\n    return stations;\n}\n\n/**\n * A literal object with non-delimited event names\n * as keys and callback functions as values.\n */\nexport interface CallbackMap {\n    [eventName: string]: Function;\n}\n","import {EventStation} from './EventStation';\n\n(<any>EventStation).EventStation = EventStation;\n(<any>EventStation).default = EventStation;\n\nObject.defineProperty(EventStation, '__esModule', { value: true });\n\nexport default EventStation;\n"],"names":["EventStation","injection.deps","injection.inject","options.config","options.reset","injection.reset","config","options.mergeOptions","options.globalOptions","options.assertOptions"],"mappings":"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"}